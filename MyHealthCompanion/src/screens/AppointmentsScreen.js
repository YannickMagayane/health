import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  FlatList,
  Alert,
  ScrollView,
  Modal,
  Platform,
  TouchableOpacity,
} from 'react-native';
// Removed AsyncStorage direct import
import * as Notifications from 'expo-notifications';
import DateTimePicker from '@react-native-community/datetimepicker';
import { COLORS, FONT_SIZES, SPACING, GlobalStyles } from '../styles/theme';
import * as AppointmentService from '../services/appointmentService'; // Import appointment service

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

const AppointmentsScreen = ({ navigation }) => {
  const [appointments, setAppointments] = useState([]);
  const [isAddModalVisible, setIsAddModalVisible] = useState(false);

  const [doctorName, setDoctorName] = useState('');
  const [appointmentDate, setAppointmentDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showTimePicker, setShowTimePicker] = useState(false);
  const [location, setLocation] = useState('');
  const [notes, setNotes] = useState('');

  const requestNotificationPermissions = async () => {
    const { status } = await Notifications.getPermissionsAsync();
    if (status === 'granted') return true;
    const { status: newStatus } = await Notifications.requestPermissionsAsync();
    return newStatus === 'granted';
  };

  const loadAppointmentsData = useCallback(async () => {
    const loadedAppointments = await AppointmentService.getAppointments();
    setAppointments(loadedAppointments);
  }, []);

  useEffect(() => {
    loadAppointmentsData();
  }, [loadAppointmentsData]);

  const handleDateChange = (event, selectedDate) => {
    setShowDatePicker(false);
    if (selectedDate) {
        const newDate = new Date(appointmentDate);
        newDate.setFullYear(selectedDate.getFullYear());
        newDate.setMonth(selectedDate.getMonth());
        newDate.setDate(selectedDate.getDate());
        setAppointmentDate(newDate);
        setShowTimePicker(true);
    }
  };

  const handleTimeChange = (event, selectedTime) => {
    setShowTimePicker(false);
    if (selectedTime) {
        const newDateTime = new Date(appointmentDate);
        newDateTime.setHours(selectedTime.getHours());
        newDateTime.setMinutes(selectedTime.getMinutes());
        setAppointmentDate(newDateTime);
    }
  };

  // This function remains in the screen as it directly uses Alert and Notifications API
  // and is specific to the UI flow here.
  const scheduleNotificationHandler = async (appointmentForNotification) => {
    const hasPermission = await requestNotificationPermissions();
    if (!hasPermission) {
      Alert.alert("Permissions", "Notifications désactivées. Activez-les pour recevoir des rappels.");
      return null;
    }
    const trigger = new Date(appointmentForNotification.date);
    if (trigger <= new Date()) return null;

    let reminderTime = new Date(trigger);
    reminderTime.setDate(trigger.getDate() - 1);
    reminderTime.setHours(9, 0, 0, 0);

    if (reminderTime <= new Date()) {
        reminderTime = new Date(trigger);
        reminderTime.setHours(trigger.getHours() - 1);
    }
    if (reminderTime <= new Date()) return null;

    try {
      return await Notifications.scheduleNotificationAsync({
        content: {
          title: 'Rappel de Consultation Médicale',
          body: `RDV avec ${appointmentForNotification.doctor} à ${new Date(appointmentForNotification.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}. Lieu: ${appointmentForNotification.location}`,
          data: { appointmentId: appointmentForNotification.id }, // Use the actual ID if available, or temp for new ones
          sound: 'default',
        },
        trigger: reminderTime,
      });
    } catch (e) {
      console.error("Error scheduling notification:", e);
      Alert.alert("Erreur Notification", "Impossible de planifier le rappel.");
      return null;
    }
  };

  const handleAddAppointment = async () => {
    if (!doctorName.trim() || !location.trim()) {
      Alert.alert('Erreur', 'Veuillez entrer le nom du médecin/spécialité et le lieu.');
      return;
    }

    let notificationId = null;
    const tempAppointmentDataForNotification = { // Used for scheduling before actual save
        id: 'temp-' + Date.now().toString(),
        doctor: doctorName.trim(),
        date: appointmentDate.toISOString(),
        location: location.trim(),
    };

    if (appointmentDate > new Date()) {
      notificationId = await scheduleNotificationHandler(tempAppointmentDataForNotification);
    }

    const newAppointmentData = {
      // ID will be generated by the service
      doctor: doctorName.trim(),
      date: appointmentDate.toISOString(),
      location: location.trim(),
      notes: notes.trim(),
      notificationId, // This will be the actual ID from Notifications.scheduleNotificationAsync
    };

    const updatedAppointments = await AppointmentService.addAppointment(newAppointmentData);
    if (updatedAppointments) {
      setAppointments(updatedAppointments);
      setDoctorName('');
      setAppointmentDate(new Date());
      setLocation('');
      setNotes('');
      setIsAddModalVisible(false);
      Alert.alert('Succès', `Rendez-vous enregistré.${notificationId ? ' Un rappel a été programmé.' : ''}`);
    } else {
      Alert.alert('Erreur', 'Impossible d\'enregistrer le rendez-vous.');
    }
  };

  const renderAppointmentItem = ({ item }) => {
    const isPast = new Date(item.date) < new Date();
    return (
      <View style={[styles.appointmentItem, isPast ? styles.pastAppointment : styles.futureAppointment]}>
        <Text style={styles.doctorName}>{item.doctor}</Text>
        <Text style={styles.appointmentText}>Date: {new Date(item.date).toLocaleDateString([], { year: 'numeric', month: 'long', day: 'numeric' })}</Text>
        <Text style={styles.appointmentText}>Heure: {new Date(item.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</Text>
        <Text style={styles.appointmentText}>Lieu: {item.location}</Text>
        {item.notes ? <Text style={styles.appointmentNotes}>Notes: {item.notes}</Text> : null}
        {item.notificationId && !isPast && <Text style={styles.reminderSetText}>Rappel Programmé</Text>}
      </View>
    );
  };

  return (
    <View style={styles.screenContainer}>
      <TouchableOpacity
        style={[GlobalStyles.button, styles.addAppointmentButton]}
        onPress={() => {
          setAppointmentDate(new Date());
          setShowDatePicker(false);
          setShowTimePicker(false);
          setIsAddModalVisible(true);
        }}
      >
        <Text style={GlobalStyles.buttonText}>Ajouter une Consultation</Text>
      </TouchableOpacity>

      <Modal visible={isAddModalVisible} animationType="slide" onRequestClose={() => setIsAddModalVisible(false)}>
        <ScrollView style={GlobalStyles.modalContainer}>
          <Text style={styles.modalTitle}>Ajouter une Consultation</Text>
          <Text style={GlobalStyles.label}>Médecin/Spécialité:</Text>
          <TextInput style={GlobalStyles.input} placeholder="Dr. Nom / Cardiologue" value={doctorName} onChangeText={setDoctorName} />

          <Text style={GlobalStyles.label}>Date et Heure:</Text>
          <TouchableOpacity onPress={() => setShowDatePicker(true)} style={styles.dateDisplayButton}>
            <Text style={styles.dateDisplayText}>{appointmentDate.toLocaleString([], { weekday:'short', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</Text>
          </TouchableOpacity>

          {showDatePicker && (
            <DateTimePicker value={appointmentDate} mode="date" display="default" onChange={handleDateChange} minimumDate={new Date()} />
          )}
          {showTimePicker && (
            <DateTimePicker value={appointmentDate} mode="time" display="default" onChange={handleTimeChange} />
          )}

          <Text style={GlobalStyles.label}>Lieu:</Text>
          <TextInput style={GlobalStyles.input} placeholder="Nom et adresse du lieu" value={location} onChangeText={setLocation} />

          <Text style={GlobalStyles.label}>Notes / Diagnostic (optionnel):</Text>
          <TextInput style={[GlobalStyles.input, styles.multilineInput]} placeholder="Motif, préparation, etc." value={notes} onChangeText={setNotes} multiline />

          <View style={styles.modalActions}>
            <TouchableOpacity style={[GlobalStyles.button, styles.saveModalButton]} onPress={handleAddAppointment}>
              <Text style={GlobalStyles.buttonText}>Enregistrer</Text>
            </TouchableOpacity>
            <TouchableOpacity style={[GlobalStyles.button, styles.cancelModalButton]} onPress={() => setIsAddModalVisible(false)}>
              <Text style={GlobalStyles.buttonText}>Annuler</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </Modal>

      <Text style={GlobalStyles.sectionTitle}>Mes Consultations</Text>
      <FlatList
        data={appointments}
        renderItem={renderAppointmentItem}
        keyExtractor={(item) => item.id}
        ListEmptyComponent={<Text style={styles.emptyListText}>Aucune consultation enregistrée.</Text>}
        contentContainerStyle={{ paddingBottom: SPACING.large }}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  screenContainer: { ...GlobalStyles.container },
  modalTitle: { ...GlobalStyles.titleText, textAlign: 'center', color: COLORS.primary, marginBottom: SPACING.large },
  multilineInput: { minHeight: 100, textAlignVertical: 'top' },
  dateDisplayButton: { ...GlobalStyles.input, justifyContent: 'center', minHeight: 50 },
  dateDisplayText: { fontSize: FONT_SIZES.medium, color: COLORS.darkGray },
  modalActions: { marginTop: SPACING.medium, flexDirection: 'row', justifyContent: 'space-between' },
  saveModalButton: { flex: 1, marginRight: SPACING.small, backgroundColor: COLORS.success },
  cancelModalButton: { flex: 1, marginLeft: SPACING.small, backgroundColor: COLORS.danger },
  addAppointmentButton: { marginBottom: SPACING.medium },
  appointmentItem: {
    backgroundColor: COLORS.white,
    padding: SPACING.medium,
    borderRadius: 8,
    marginBottom: SPACING.medium,
    borderWidth: 1,
    shadowColor: COLORS.black,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 2,
  },
  pastAppointment: { borderColor: COLORS.mediumGray, backgroundColor: COLORS.lightGray },
  futureAppointment: { borderColor: COLORS.primary, backgroundColor: COLORS.white },
  doctorName: { fontSize: FONT_SIZES.large, fontWeight: 'bold', color: COLORS.primary, marginBottom: SPACING.xsmall },
  appointmentText: { fontSize: FONT_SIZES.medium, color: COLORS.darkGray, marginBottom: SPACING.xsmall },
  appointmentNotes: { fontSize: FONT_SIZES.medium, color: COLORS.darkGray, fontStyle: 'italic', marginTop: SPACING.small },
  reminderSetText: { fontSize: FONT_SIZES.small, color: COLORS.success, fontWeight: 'bold', marginTop: SPACING.small },
  emptyListText: { textAlign: 'center', marginTop: SPACING.large, fontSize: FONT_SIZES.medium, color: COLORS.darkGray },
});

export default AppointmentsScreen;
