import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  FlatList,
  Alert,
  Dimensions,
  ScrollView,
  TouchableOpacity,
  Platform,
} from 'react-native';
// Removed AsyncStorage direct import
import { LineChart } from 'react-native-chart-kit';
import { Picker } from '@react-native-picker/picker';
import { getSpecialtySuggestion } from '../utils/symptomUtils';
import { COLORS, FONT_SIZES, SPACING, GlobalStyles } from '../styles/theme';
import * as SymptomService from '../services/symptomService'; // Import symptom service

const screenWidth = Dimensions.get('window').width;

const SymptomTrackerScreen = () => {
  const [symptomName, setSymptomName] = useState('');
  const [intensity, setIntensity] = useState(5);
  const [symptomDate, setSymptomDate] = useState(new Date().toISOString().split('T')[0]);
  const [symptoms, setSymptoms] = useState([]);
  const [selectedSymptomForChart, setSelectedSymptomForChart] = useState(null);
  const [chartData, setChartData] = useState(null);

  const chartConfigThemed = {
    backgroundGradientFrom: COLORS.lightGray,
    backgroundGradientFromOpacity: 1,
    backgroundGradientTo: COLORS.lightGray,
    backgroundGradientToOpacity: 1,
    color: (opacity = 1) => COLORS.primary,
    labelColor: (opacity = 1) => COLORS.darkGray,
    strokeWidth: 2,
    barPercentage: 0.5,
    useShadowColorFromDataset: false,
    decimalPlaces: 0,
    propsForDots: {
      r: "4",
      strokeWidth: "2",
      stroke: COLORS.accent
    }
  };

  const loadSymptomsData = useCallback(async () => {
    const loadedSymptoms = await SymptomService.getSymptoms();
    setSymptoms(loadedSymptoms);
    if (loadedSymptoms.length > 0 && !selectedSymptomForChart) {
        const uniqueNames = Array.from(new Set(loadedSymptoms.map(s => s.name)));
        if (uniqueNames.length > 0) {
             setSelectedSymptomForChart(uniqueNames[uniqueNames.length -1]);
        }
    }
  }, [selectedSymptomForChart]); // selectedSymptomForChart dependency to re-evaluate if it changes externally

  useEffect(() => {
    loadSymptomsData();
  }, [loadSymptomsData]);

  useEffect(() => {
    if (selectedSymptomForChart && symptoms.length > 0) {
      const filteredSymptoms = symptoms.filter(s => s.name === selectedSymptomForChart);
      if (filteredSymptoms.length >= 1) {
        setChartData({
          labels: filteredSymptoms.map(s => new Date(s.date).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })),
          datasets: [{
            data: filteredSymptoms.map(s => s.intensity),
            color: (opacity = 1) => COLORS.accent,
            strokeWidth: 2,
          }],
          legend: [`Intensité de: ${selectedSymptomForChart}`],
        });
      } else {
        setChartData(null);
      }
    } else {
      setChartData(null);
    }
  }, [selectedSymptomForChart, symptoms]);

  const handleSaveSymptom = async () => {
    if (!symptomName.trim() || !symptomDate.trim()) {
      Alert.alert('Erreur', 'Veuillez entrer le nom et la date du symptôme.');
      return;
    }
    const newSymptomData = {
      // ID is generated by the service
      name: symptomName.trim(),
      intensity: intensity,
      date: symptomDate.trim(),
    };

    const updatedSymptoms = await SymptomService.addSymptom(newSymptomData);
    if (updatedSymptoms) {
      setSymptoms(updatedSymptoms);

      const suggestion = getSpecialtySuggestion(newSymptomData.name);
      Alert.alert(
        'Symptôme Enregistré',
        `Suggestion de spécialiste : ${suggestion}\nCeci est une suggestion et ne remplace pas un avis médical.`,
      );

      if (!selectedSymptomForChart || selectedSymptomForChart !== newSymptomData.name) {
        if (updatedSymptoms.filter(s => s.name === newSymptomData.name).length >= 1) {
           setSelectedSymptomForChart(newSymptomData.name);
        }
      }
      setSymptomName('');
    } else {
      Alert.alert('Erreur', 'Impossible d\'enregistrer le symptôme.');
    }
  };

  const renderSymptomItem = ({ item }) => (
    <View style={styles.symptomItem}>
      <Text style={styles.symptomText}>{item.name} (Intensité: {item.intensity})</Text>
      <Text style={styles.symptomDateText}>{new Date(item.date).toLocaleDateString()}</Text>
    </View>
  );

  const uniqueSymptomNames = Array.from(new Set(symptoms.map(s => s.name)));

  return (
    <ScrollView style={styles.scrollViewContainer}>
      <View style={styles.container}>
        <Text style={GlobalStyles.sectionTitle}>Enregistrer un Symptôme</Text>
        <TextInput
          style={GlobalStyles.input}
          placeholder="Nom du symptôme (ex: Fièvre)"
          value={symptomName}
          onChangeText={setSymptomName}
        />
        <Text style={GlobalStyles.label}>Intensité: {intensity}</Text>
        <View style={styles.intensityContainer}>
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(val => (
            <TouchableOpacity
              key={val}
              style={[styles.intensityButton, intensity === val && styles.intensityButtonSelected]}
              onPress={() => setIntensity(val)}
            >
              <Text style={intensity === val ? styles.intensityButtonTextSelected : styles.intensityButtonText}>{val}</Text>
            </TouchableOpacity>
          ))}
        </View>
        <TextInput
          style={GlobalStyles.input}
          placeholder="Date (YYYY-MM-DD)"
          value={symptomDate}
          onChangeText={setSymptomDate}
          keyboardType="numeric"
        />
        <TouchableOpacity style={GlobalStyles.button} onPress={handleSaveSymptom}>
            <Text style={GlobalStyles.buttonText}>Enregistrer le Symptôme</Text>
        </TouchableOpacity>

        <Text style={GlobalStyles.sectionTitle}>Historique des Symptômes</Text>
        <FlatList
          data={symptoms}
          renderItem={renderSymptomItem}
          keyExtractor={(item) => item.id}
          ListEmptyComponent={<Text style={styles.emptyListText}>Aucun symptôme enregistré.</Text>}
          style={styles.listStyle}
        />

        <Text style={GlobalStyles.sectionTitle}>Graphique d'Évolution</Text>
        {symptoms.length > 0 ? (
          <View style={styles.pickerWrapper}>
            <Picker
              selectedValue={selectedSymptomForChart}
              onValueChange={(itemValue) => setSelectedSymptomForChart(itemValue)}
              style={styles.pickerStyle}
              itemStyle={styles.pickerItemStyle}
            >
              <Picker.Item label="-- Sélectionnez un symptôme --" value={null} />
              {uniqueSymptomNames.map(name => (
                <Picker.Item key={name} label={name} value={name} />
              ))}
            </Picker>
          </View>
        ) : (
            <Text style={styles.emptyListText}>Enregistrez des symptômes pour voir le graphique.</Text>
        )}

        {chartData && chartData.labels && chartData.labels.length > 0 ? (
          <LineChart
            data={chartData}
            width={screenWidth - SPACING.medium * 2}
            height={250}
            chartConfig={chartConfigThemed}
            bezier
            style={styles.chartStyle}
          />
        ) : (
          selectedSymptomForChart && <Text style={styles.emptyListText}>Pas assez de données pour "{selectedSymptomForChart}".</Text>
        )}
         {!selectedSymptomForChart && symptoms.length > 0 && <Text style={styles.emptyListText}>Sélectionnez un symptôme.</Text>}
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  scrollViewContainer: {
    flex: 1,
    backgroundColor: COLORS.lightGray,
  },
  container: {
    ...GlobalStyles.container,
  },
  intensityContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: SPACING.medium,
    flexWrap: 'wrap',
  },
  intensityButton: {
    backgroundColor: COLORS.white,
    borderWidth: 1,
    borderColor: COLORS.mediumGray,
    paddingVertical: SPACING.small,
    paddingHorizontal: SPACING.medium,
    borderRadius: 20,
    width: (screenWidth / 6) - SPACING.medium,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
    margin: SPACING.xsmall,
  },
  intensityButtonSelected: {
    backgroundColor: COLORS.primary,
    borderColor: COLORS.primary,
  },
  intensityButtonText: {
    color: COLORS.primary,
    fontSize: FONT_SIZES.medium,
  },
  intensityButtonTextSelected: {
    color: COLORS.white,
    fontSize: FONT_SIZES.medium,
    fontWeight: 'bold',
  },
  symptomItem: {
    backgroundColor: COLORS.white,
    padding: SPACING.medium,
    borderRadius: 8,
    marginBottom: SPACING.small,
    borderWidth: 1,
    borderColor: COLORS.lightGray,
     shadowColor: COLORS.black,
     shadowOffset: { width: 0, height: 1 },
     shadowOpacity: 0.05,
     shadowRadius: 2,
     elevation: 1,
  },
  symptomText: {
    fontSize: FONT_SIZES.medium,
    color: COLORS.darkGray,
    fontWeight: '500',
  },
  symptomDateText: {
    fontSize: FONT_SIZES.small,
    color: COLORS.darkGray,
    opacity: 0.7,
    marginTop: SPACING.xsmall,
  },
  listStyle: {
    maxHeight: 250,
    marginBottom: SPACING.medium,
  },
  chartStyle: {
    marginVertical: SPACING.medium,
    borderRadius: 16,
    alignSelf: 'center',
  },
  pickerWrapper: {
    backgroundColor: COLORS.white,
    borderWidth: 1,
    borderColor: COLORS.mediumGray,
    borderRadius: 8,
    marginBottom: SPACING.medium,
    height: Platform.OS === 'ios' ? 120 : 60,
    justifyContent: 'center',
  },
  pickerStyle: {
  },
  pickerItemStyle: {
    height:120,
    fontSize: FONT_SIZES.medium,
  },
  emptyListText: {
    textAlign: 'center',
    color: COLORS.darkGray,
    fontSize: FONT_SIZES.medium,
    paddingVertical: SPACING.medium,
  },
});

export default SymptomTrackerScreen;
